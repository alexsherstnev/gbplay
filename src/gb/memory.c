#include "memory.h"
#include "gb.h"  // IWYU pragma: keep

// DMG Boot ROM
static const uint8_t DMG_BOOT_ROM[] = {
  0x31,0xFE,0xFF,0xAF,0x21,0xFF,0x9F,0x32,0xCB,0x7C,0x20,0xFB,0x21,0x26,0xFF,0x0E,
  0x11,0x3E,0x80,0x32,0xE2,0x0C,0x3E,0xF3,0xE2,0x32,0x3E,0x77,0x77,0x3E,0xFC,0xE0,
  0x47,0x11,0x04,0x01,0x21,0x10,0x80,0x1A,0xCD,0x95,0x00,0xCD,0x96,0x00,0x13,0x7B,
  0xFE,0x34,0x20,0xF3,0x11,0xD8,0x00,0x06,0x08,0x1A,0x13,0x22,0x23,0x05,0x20,0xF9,
  0x3E,0x19,0xEA,0x10,0x99,0x21,0x2F,0x99,0x0E,0x0C,0x3D,0x28,0x08,0x32,0x0D,0x20,
  0xF9,0x2E,0x0F,0x18,0xF3,0x67,0x3E,0x64,0x57,0xE0,0x42,0x3E,0x91,0xE0,0x40,0x04,
  0x1E,0x02,0x0E,0x0C,0xF0,0x44,0xFE,0x90,0x20,0xFA,0x0D,0x20,0xF7,0x1D,0x20,0xF2,
  0x0E,0x13,0x24,0x7C,0x1E,0x83,0xFE,0x62,0x28,0x06,0x1E,0xC1,0xFE,0x64,0x20,0x06,
  0x7B,0xE2,0x0C,0x3E,0x87,0xE2,0xF0,0x42,0x90,0xE0,0x42,0x15,0x20,0xD2,0x05,0x20,
  0x4F,0x16,0x20,0x18,0xCB,0x4F,0x06,0x04,0xC5,0xCB,0x11,0x17,0xC1,0xCB,0x11,0x17,
  0x05,0x20,0xF5,0x22,0x23,0x22,0x23,0xC9,0xCE,0xED,0x66,0x66,0xCC,0x0D,0x00,0x0B,
  0x03,0x73,0x00,0x83,0x00,0x0C,0x00,0x0D,0x00,0x08,0x11,0x1F,0x88,0x89,0x00,0x0E,
  0xDC,0xCC,0x6E,0xE6,0xDD,0xDD,0xD9,0x99,0xBB,0xBB,0x67,0x63,0x6E,0x0E,0xEC,0xCC,
  0xDD,0xDC,0x99,0x9F,0xBB,0xB9,0x33,0x3E,0x3C,0x42,0xB9,0xA5,0xB9,0xA5,0x42,0x3C,
  0x21,0x04,0x01,0x11,0xA8,0x00,0x1A,0x13,0xBE,0x20,0xFE,0x23,0x7D,0xFE,0x34,0x20,
  0xF5,0x06,0x19,0x78,0x86,0x23,0x05,0x20,0xFB,0x86,0x20,0xFE,0x3E,0x01,0xE0,0x50
};

static GB_result_t allocate_memory_block(GB_emulator_t *gb, void **ptr, size_t num, size_t size) {
  GB_result_t result = GB_SUCCESS;
  *ptr = calloc(num, size);
  if (!(*ptr)) {
    GB_memory_free(gb);
    result = GB_ERROR_OUT_OF_MEMORY;
  }

  return result;
}

static void safe_free(void **ptr) {
  if (*ptr) {
    free(*ptr);
    *ptr = NULL;
  }
}

GB_result_t GB_memory_init(GB_emulator_t *gb) {
  if (!gb) { return GB_ERROR_INVALID_EMULATOR; }
 
  // Initialize Boot ROM
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.boot_rom, 0xFF, sizeof(uint8_t)));
  memcpy(gb->memory.boot_rom, DMG_BOOT_ROM, sizeof(DMG_BOOT_ROM));

  // Initialize VRAM (8KB)
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.vram, 0x2000, sizeof(uint8_t)));

  // Initialize WRAM (8KB)
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.wram, 0x2000, sizeof(uint8_t)));

  // Echo RAM is a mirror of WRAM, so no need to allocated separate memory
  gb->memory.echo_ram = gb->memory.wram;

  // Initialize OAM (160 bytes)
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.oam, 0xA0, sizeof(uint8_t)));

  // Initialize I/O registers (128 bytes)
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.io, 0x80, sizeof(uint8_t)));
  gb->memory.io[GB_MEMORY_IO_OFFSET(GB_HARDWARE_REGISTER_KEY1)] = 0xFF;

  // Initialize HRAM (127 bytes)
  GB_TRY(allocate_memory_block(gb, (void **)&gb->memory.hram, 0x7F, sizeof(uint8_t)));
  gb->memory.hram[0] = 0x01;

  // Initialize the interrupt enable register
  gb->memory.ie = 0;
 
  // Initialize MBC controller
  gb->memory.mbc.rom_bank = 0;
  gb->memory.mbc.ram_bank = 0;
  gb->memory.mbc.mode = 0;
  gb->memory.mbc.ram_enabled = false;

  return GB_SUCCESS;
}

GB_result_t GB_memory_free(GB_emulator_t *gb) {
  if (!gb) { return GB_ERROR_INVALID_EMULATOR; }

  gb->memory.mbc.rom_bank = 0;
  gb->memory.mbc.ram_bank = 0;
  gb->memory.mbc.mode = 0;
  gb->memory.mbc.ram_enabled = false;

  gb->memory.ie = 0;
  safe_free((void **)&gb->memory.hram);
  safe_free((void **)&gb->memory.io);
  safe_free((void **)&gb->memory.oam);
  gb->memory.echo_ram = NULL;
  safe_free((void **)&gb->memory.wram);

  for (uint8_t ram_index = 0; ram_index < 16; ram_index++) {
    safe_free((void **)&gb->memory.external_ram[ram_index]);
  }

  safe_free((void **)&gb->memory.vram);

  for (uint16_t rom_index = 0; rom_index < 512; rom_index++) {
    safe_free((void **)&gb->memory.rom_x[rom_index]);
  }

  safe_free((void **)&gb->memory.rom_0);
  safe_free((void **)&gb->memory.boot_rom);

  return GB_SUCCESS;
}

GB_result_t GB_memory_read_rom_header(GB_emulator_t *gb, GB_rom_header_t *header) {
  if (!gb)               { return GB_ERROR_INVALID_EMULATOR;      }
  if (!header)           { return GB_ERROR_INVALID_ARGUMENT;      }
  if (!gb->memory.rom_0) { return GB_ERROR_INVALID_MEMORY_ACCESS; }

  // The ROM header starts at addr 0x0100
  const uint8_t *header_start = gb->memory.rom_0 + 0x0100;

  // Copy the ROM header
  memcpy(header, header_start, sizeof(GB_rom_header_t));

  return GB_SUCCESS;
}
